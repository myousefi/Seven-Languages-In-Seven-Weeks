# Erlang: Observations and Learnings

- **Concurrency and Reliability**: Erlang excels in scalable concurrency and reliability, making hard things easy but easy things hard.

- **Lightweight Processes**: Processes in Erlang are lightweight, similar to actors in Scala.

- **Data Structures**: Erlang allows mixing lists and tuples, enabling pattern matching and variable assignment.

- **Bit-Matching**: Bit-matching in Erlang is powerful for low-level tasks, packing data into bytes efficiently.

- **Dynamic Typing**: Dynamic typing in Erlang reduces the need to worry about assigning types to data elements.

- **Tail Recursion**: Tail recursion is particularly useful in Erlang, similar to Prolog.

- **Efficient Computation**: Erlang efficiently calculates Factorial and Fibonacci of large numbers.

- **List Comprehensions**: List comprehensions in Erlang are an elegant and powerful abstraction for transforming lists.

- **Concurrency Simplified**: Concurrency, although inherently difficult, is simplified in Erlang.

- **Process Linking**: Linking two processes together is straightforward in Erlang.

- **Syntax Differences**: Erlang's syntax lacks the simplicity and beauty compared to languages like Ruby.

- **Immutable Variables**: Immutable variables starting with uppercase letters can be initially confusing.

- **Control Structures**: Control structures in Erlang have a steeper learning curve compared to other languages.

- **Higher-Order Functions**: Solving simple problems using higher-order functions in Erlang can be challenging.

- **Punctuation as Syntax**: Erlang's use of punctuation (",", ";" and ".") as syntax may seem unnecessary.

- **Strengths**: Erlang's strengths lie in its dynamic nature, reliability, lightweight processes, and the OTP enterprise libraries.

- **Error Handling Philosophy**: The "let it crash" philosophy is embraced in Erlang's approach to error handling.
